项目测试说明（tests 模块）

概览
- 所有测试集中在 `tests/` 模块，不影响部署产物。
- 测试不依赖外部 Kafka/数据库，均使用内存组件或模拟对象。
- 运行：`source .tooling/env.sh && mvn -pl tests -am verify`。

检查点（按流程图）
- HTTP 请求进入（/kline）：ApiControllerHttpTest.testFixedPortWithKafkaData_printAndValidate
- HTTP 接口（无端口依赖）：ApiControllerMockMvcTest（基于 MockMvc，不启 Tomcat）
- 名称查询（缓存优先，未命中回源）：NameResolverImplTest 两个用例
- K线数据查询（L2 命中与未命中回 DB 再回填）：
  - RedisKlineCacheTest 覆盖 L2 行为
  - KlineRepositoryImplTest 覆盖 DB 回退与回填
- 写入链路（Kafka → 解析 → 写 L2/DB）：
  - KafkaE2eTest 覆盖从 JSON（模拟 Kafka）到 DAO/缓存/HTTP 的全流程
- Kafka 关闭（不拉取、不建容器）：
  - KafkaConsumerDisabledTest 验证默认不加载 @KafkaListener Bean

- 目的：按 api_restriction.txt 验证对外接口的异常流程。
- 异常用例（testBadRequestWhenMissingRequiredParams）
  - 输入：缺失 `marketId` 或缺失 `stockcode`。
  - 输出：HTTP 400；JSON `{ code: 非"0", message: 错误原因, data: null, list: [] }`。
- 异常用例（testBadRequestOnInvalidLimitType）
  - 输入：`/kline?stockcode={code}&marketId=SZ&limit=abc`（类型错误）。
  - 输出：HTTP 400；JSON `{ code: 非"0" }`。

2) 接口 HTTP 测试（合并集）：ApiControllerHttpTest
- 目的：验证接口可用性与返回结构（使用随机端口，避免环境端口限制），并与 kafka_data 一致。
- 输入：从测试资源 `kafka_data.json` 读取 20 条数据映射为内存 DAO；预置名称缓存 `(300033,33)->wuhan city`；GET `/kline?stockcode=300033&marketId=33`（随机端口通过 @LocalServerPort 注入）。
  - 输出：
  - 打印接口返回值到测试输出（可在 surefire 报告查看）；
  - HTTP 200；JSON 包含 `code`、`data`、`list`；
  - `list.size()==20`，首条 `20200101 0940`，末条 `20200101 0959`，顺序与 kafka_data 一致。
  - 异常：缺少必填参数/参数类型错误返回 HTTP 400，JSON `code` 非 "0"。

3) Kafka 消费者单测：TimelineConsumerTest
- 目的：在无 broker 情况下模拟消息处理。
- 输入：构造 `KlineResponse` 并直接调用 `TimelineConsumer.run(resp)`（使用 Mockito 模拟 `KlineRepository`）。
- 输出：验证 `KlineRepository.upsertBatch(resp)` 恰好被调用 1 次。

4) 仓储实现测试：KlineRepositoryImplTest
- 目的：验证缓存回退与批量写入行为。
- 用例一（findRange 回退）
  - 输入：仅向 DAO 插入三条数据；调用 `findRange(code, SZ, 2, 3, null)`。
  - 输出：返回 2 条，并将结果写入缓存；更换空 DAO 但复用缓存再次查询仍返回 2 条。
- 用例二（upsertBatch）
  - 输入：构造含 2 条数据的 `KlineResponse` 调用 `upsertBatch`。
  - 输出：DAO 与缓存均可读到 2 条数据。

5) 内存 DAO 测试：KlineDaoTest
- 目的：验证插入与范围/限流查询。
- 输入：插入 ts=1,2,3；查询全部与 limit=2。
- 输出：全部返回 3 条；限流返回 2 条。

6) 内存缓存测试：RedisKlineCacheTest
- 目的：验证范围与限流行为。
- 输入：放入 ts=1,2,3；按区间与 limit 查询。
- 输出：区间 2–3 返回 2 条；limit=2 返回 2 条；超出区间返回 0 条。

7) 名称解析测试：NameResolverImplTest
- 目的：验证缓存优先与回源填充。
- 用例一：首次解析
  - 输入：缓存未命中；调用 `resolve(600000, SH)`（Counting stub 统计外部调用次数）。
  - 输出：返回 `NAME-600000-SH`，外部调用计数为 1 并写入缓存。
- 用例二：缓存命中
  - 输入：同一请求再次解析。
  - 输出：返回缓存值，外部调用计数仍为 1（未增加）。

8) 聚合根范围查询：KlineResponseTest
- 目的：验证聚合根的区间过滤。
- 输入：加入 ts=1,2,3；调用 `getDataInRange(2,3)`。
- 输出：返回 2 条。

错误响应统一格式（全局异常处理）
- 由 `GlobalExceptionHandler` 统一包装：
  - Bad Request：HTTP 400；`{ code: "400", message, data: null, list: [] }`。
  - Server Error：HTTP 500；`{ code: "500", message: "internal error", data: null, list: [] }`。
9) 端到端工作流测试：KafkaE2eTest
- 目的：使用提供的 `uml/kafka_data.json` 模拟 Kafka 数据整体链路，验证写入 DAO 与 Redis 缓存，并按契约查询返回。
- 输入：从测试资源 `tests/src/test/resources/kafka_data.json` 读取；构造 `KlineResponse`（price 映射为 OHLC，vol=1；`date`+`time` 转 epoch 秒），调用 `TimelineConsumer.run(...)`。预置名称缓存：`(300033,33) -> wuhan city`。
- 输出：
  - DAO 与缓存数据条数均等于 JSON 条目数；
  - GET `/kline?stockcode=300033&marketId=33` 返回 `{ code:"0", data:{stockName:"wuhan city"}, list:[…] }`，且 list 首末时间为 0940 与 0959。

运行提示
- 单独运行固定端口用例（避免多模块“无测试报错”）：
  - `mvn -f tests/pom.xml -Dtest=com.example.kline.interfaces.rest.ApiControllerHttpTest test`
  - 或 `mvn -pl tests -am -Dtest=com.example.kline.interfaces.rest.ApiControllerHttpTest -DfailIfNoTests=false test`
- 确保 18080 端口空闲，否则用例会因端口占用失败。

10) 接口 HTTP（无端口依赖）测试：ApiControllerMockMvcTest
- 目的：在不启端口的情况下验证 /kline 返回契约结构，计入覆盖率。
- 输入：Mock KlineRepository 与 NameResolver，构造 1 条数据；GET /kline?stockcode=300033&marketId=33。
- 输出：HTTP 200；JSON `{ code:"0", data.stockName:"wuhan city", list:[...] }`；缺参返回 400。
 - 新增：invalid limit 类型（limit=abc）返回 400；ts=null 时 date=19700101、time=0000，且按 ts 升序排序。
