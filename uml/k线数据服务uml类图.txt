---
config:
  layout: elk
---
classDiagram
direction TB
  namespace Interfaces {
        class ApiController {
          +getKline(stockcode, marketId, startTs, endTs, limit) KlineResponse
        }
        class TimelineConsumer {
          +run() void
        }
  }
  namespace Domain {
        class KlineResponse {
          +stockcode String
          +marketId String
          +stockName String
          +data List~PricePoint~
          --
          +addPricePoint(point) void
          +getDataInRange(startTs, endTs) List~PricePoint~
          +validateData() boolean
        }
        class PricePoint {
          +ts Long
          +open BigDecimal
          +high BigDecimal
          +low BigDecimal
          +close BigDecimal
          +vol Long
          --
          +isValid() boolean
        }
        class NameResolver {
          +resolve(stockcode, marketId) String
        }
        class KlineRepository {
          +findRange(stockcode, marketId, startTs, endTs, limit) KlineResponse
          +upsertBatch(response) void
        }
  }
  namespace Infrastructure {
        class KlineRepositoryImpl {
          -klineCache: RedisKlineCache
          -klineDao: KlineDao
          +findRange(...) KlineResponse
          +upsertBatch(response) void
        }
        class NameResolverImpl {
          -nameCache: RedisNameCache
          -nameServiceHttp: NameServiceHttp
          +resolve(stockcode, marketId) String
        }
        class RedisNameCache {
          -redis: Redis
          +getName(stockcode, marketId) String
          +setName(stockcode, marketId, name, ttlSec) void
        }
        class NameServiceHttp {
          -feignClient: NameServiceFeignClient
          +fetchName(stockcode, marketId) String
        }
        class KlineDao {
          +selectRange(...) List~KlineDO~
          +insertBatch(...) int
        }
        class Database {
        }
        class Redis {
        }
        class RedisKlineCache {
          -redis: Redis
          +getRange(stockcode, marketId, startTs, endTs, limit) KlineResponse
          +putBatch(response, ttlSec) void
        }
  }
  namespace External {
        class NameServiceAPI {
        }
        class Kafka {
        }
  }

  <<Controller>> ApiController
  <<Consumer>> TimelineConsumer
  <<AggregateRoot>> KlineResponse
  <<ValueObject>> PricePoint
  <<DomainService>> NameResolver
  <<Repository>> KlineRepository
  <<Repository>> KlineRepositoryImpl
  <<Service>> NameResolverImpl
  <<Cache>> RedisNameCache
  <<ExternalService>> NameServiceHttp
  <<Mapper>> KlineDao
  <<Infrastructure>> Database
  <<Infrastructure>> Redis
  <<ExternalSystem>> NameServiceAPI
  <<MessageQueue>> Kafka
  <<Cache>> RedisKlineCache

    ApiController --> KlineRepository : 调用
    ApiController --> NameResolver : 调用
    TimelineConsumer --> KlineRepository : 存储数据
    KlineResponse *-- PricePoint : 聚合
    NameResolver <|-- NameResolverImpl : 实现
    NameResolverImpl --> RedisNameCache : 使用缓存
    NameResolverImpl --> NameServiceHttp : 外部调用
    KlineRepository <|-- KlineRepositoryImpl : 实现
    KlineRepositoryImpl --> RedisKlineCache : L2缓存
    KlineRepositoryImpl --> KlineDao : 数据访问
    RedisKlineCache --> Redis : 使用
    RedisNameCache --> Redis : 使用
    NameServiceHttp --> NameServiceAPI : HTTP调用
    Kafka --> TimelineConsumer : 推送消息
    KlineDao --> Database : 查询
